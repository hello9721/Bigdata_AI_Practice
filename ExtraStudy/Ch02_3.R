# 연속형 확률분포

# 이산형 확률부포와 달리 데이터로 분포를 결정짓지 못함.
# 그래서 데이터의 형태를 보고 분포를 가정 한 후 분석을 진행
# 연속형 확률분포는 특정 구간에 대한 확률밀도함수로 정의


# 정규분포

# 연속형 확률분포에서 가장 중요한 분포
# 평균을 중심으로 분산만큼 퍼진 종 모양의 분포
# 따라서 분산이 클수록 옆으로 넓게 퍼짐

library(reshape2)               # melt
library(dplyr)                  # 파이프 연산자

x <- c()                        # x 축의 값이 들어갈 빈 벡터 생성
y1 <- c()                       # 첫번째 그래프의 y 값이 들어갈 빈 벡터 생성

for ( k in seq(-20, 20, by = 0.1) ) {
                                # -20부터 20까지 0.1씩
  p <- dnorm(x = k, mean = 0, sd = 3)
                                # dnorm을 사용하여 for로 주어지는 값들을 평균이 0이고 표준편차가 3이 되도록 반환
  x <- c(x, k)                  # x에 k를 계속 누적 시킴
  y1 <- c(y1, p)                # y1에 dnorm으로 받은 값을 누적 시킴
  
}

y2 <- c()                       # 두번째 그래프의 y 값이 들어갈 빈 벡터 생성

for ( k in seq(-20, 20, by = 0.1) ) {
                                # -20부터 20까지 0.1씩
  p <- dnorm(x = k, mean = 0, sd = 10)
                                # 아까와는 달리 표준편차가 10이 되도록
  y2 <- c(y2, p)                # 위에서 받은 값을 y2에 누적, x는 아까 반복에서 받은 부분과 같으므로 생략
  
}

df <- data.frame(x = x, y1 = y1, y2 = y2)
                                # x와 y1, y2 로 데이터프레임 생성
df %>%                          # df를  melt 함수에 넣음
  melt(id.vars = c("x")) %>%    # id로 x를 갖고 value에 y1과 y2의 값이, variable에 y1의 값이면 "y1", y2의 값이면 "y2"
  ggplot(aes(x = x, y = value, col = as.factor(variable))) +
  geom_line() + geom_vline(xintercept = 0, linetype = "dashed") +
  theme_bw() + theme(legend.position = "bottom") + labs(col = "Y")
                                # x 축으로는 x의 값을, y축으로는 y1과 y2의 값, 색은 y1와 y2가 서로 다르게
                                # x가 0인 부분에 중심선을 넣고 흑백 테마로 선그래프를 그린다.
                                
# 그래프를 확인 하면 표준편차 (분산의 제곱근) 가 클 수록 양옆으로 퍼지는 그래프를 확인 할 수 있다.


# 표준 정규분포

# 정규분포를 따르는 확률변수는 선형변환을 해도 정규분포를 따른다.
# 이 성질을 이용하여 정규분포를 표준화 할 수 있는데
# 예를 들어 평균만큼 이동하면 이동한 분포의 평균은 0이 되고
# 분산으로 나누면 분포의 분산은 1이 된다.
# 그 분포들 역시 정규분포를 따르고
# 평균이 0이고 분산이 1인 정규분포를 표준 정규분포라고 정의한다.

# 표준 정규분포로 만들면 단위를 통일 하여 분석할 수 있다.
# ex) 수능 표준 점수

# 선형변환
# 원래의 값에서 더하거나 빼고나 곱하거나 나눗셈을 한 변환
# 그래프의 분포는 변하지 않는다.

x <- c()
y <- c()

for (k in seq(-4, 4, by = 0.01)) {
                
  p <- dnorm(k)               # 분산이 1이어야 한다면 표준편차도 1 이므로
                              # dnorm에 mean을 0, sd를 1로 한다면 표준 정규분포를 만들 수 있다.
  x <- c(x, k)
  y <- c(y, p)
  
}

ggplot() + geom_line(aes(x, y)) + theme_bw() + theme(legend.position = "none")


# 카이제곱 분포

# 분산은 기대값으로부터 데이터가 퍼져있는 정도이기에
# 분산이 넓게 퍼져있다면 분석 결과를 신뢰할 수 없다는 뜻이다.
# 분산은 제곱합 구조를 사용하는데 이를 사용하지 않을 경우에는 데이터가 퍼진 정도의 합이 0이 되기 때문이다.
# 카이제곱 분포는 분포의 특징을 나타내는 확률 분포
# 적합도 검정이나 독립성 검정에 활용 된다.

# 정규분포를 따르는 확률변수에 표준화를 진행하여 ( 단위 통일을 위해 )
# 표준 정규분포로 변환한 뒤 제곱을 진행하면
# 자유도가 1인 카이제곱 분포로 변환 된다.
# 독립적인 카이제곱 변수들은 가법성으로 인해 서로 더할 경우에도 그 값은 카이제곱 분포를 따른다.

# 가법성 -> p 라는 분포를 따르는 a와 b를 더한 a+b 또한 p를 따른다.

# 자유도 -> 내가 가진 정보의 수에서 추정해야하는 미지수의 개수를 뺀 값

x <- c()
y <- c()

for(k in seq(0, 30, by = 0.01)){
  
  p <- dchisq(k, df = 10)      # 카이제곱 분포에서 x = k 이고 자유도가 df일 때의 함수값

  x <- c(x, k)
  y <- c(y, p)
    
}                             # df 값이 커질수록 곡선의 최고점이 오른쪽으로 움직인다.

ggplot() + geom_line(aes(x, y)) + theme_bw() + theme(legend.position = "none")


# F 분포

# 독립된 두 집단의 분산을 비교하는 것을 목적으로 사용ㅎ나다.
# 분산을 비교할 때 데이터 간의 단위와 자료수가 다르다는 것을 주의해야 하는데
# 카이제곱 분포는 표준화 진행으로 이 문제가 해결되기에
# 두 집단을 비교할때 카이제곱의 비를 계산하여 비교한다.
# 이때 카이제곱 비가 1에 가까울 수록 분산이 동일하다고 하여 이를 F 분포라고 한다.

# df가 n1인 카이제곱과 df가 n2 인 카이제곱을 비교할 때 F의 df는 n1, n2 가 된다.

# f 분포 -> df(확률변수, 표본1의 자유도, 표본2의 자유도, ncp, log = FALSE)

x <- c()
y <- c()

for(k in seq(0, 30, by = 0.01)){
  
  p <- df(k, 5, 5)
  
  x <- c(x, k)
  y <- c(y, p)
  
}

ggplot() + geom_line(aes(x, y)) + theme_bw() + theme(legend.position = "none")
